# ruff: noqa
# Code generated by river.codegen. DO NOT EDIT.
from collections.abc import AsyncIterable, AsyncIterator
import datetime
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Mapping,
    NotRequired,
    Union,
    Tuple,
    TypedDict,
)
from typing_extensions import Annotated

from pydantic import BaseModel, Field, TypeAdapter, WrapValidator
from replit_river.error_schema import RiverError
from replit_river.client import RiverUnknownValue, translate_unknown_value

import replit_river as river


encode_NeedsenumobjectInputOneOf_in_first: Callable[
    ["NeedsenumobjectInputOneOf_in_first"], Any
] = lambda x: {
    k: v
    for (k, v) in (
        {
            "$kind": x.get("kind"),
            "value": x.get("value"),
        }
    ).items()
    if v is not None
}


class NeedsenumobjectInputOneOf_in_first(TypedDict):
    kind: Literal["in_first"]
    value: str


encode_NeedsenumobjectInputOneOf_in_second: Callable[
    ["NeedsenumobjectInputOneOf_in_second"], Any
] = lambda x: {
    k: v
    for (k, v) in (
        {
            "$kind": x.get("kind"),
            "bleep": x.get("bleep"),
        }
    ).items()
    if v is not None
}


class NeedsenumobjectInputOneOf_in_second(TypedDict):
    kind: Literal["in_second"]
    bleep: int


NeedsenumobjectInput = (
    NeedsenumobjectInputOneOf_in_first | NeedsenumobjectInputOneOf_in_second
)

encode_NeedsenumobjectInput: Callable[["NeedsenumobjectInput"], Any] = (
    lambda x: encode_NeedsenumobjectInputOneOf_in_first(x)
    if x["kind"] == "in_first"
    else encode_NeedsenumobjectInputOneOf_in_second(x)
)

NeedsenumobjectInputTypeAdapter: TypeAdapter[Any] = TypeAdapter(NeedsenumobjectInput)


class NeedsenumobjectOutputFooOneOf_out_first(BaseModel):
    kind: Literal["out_first"] = Field(
        "out_first",
        alias="$kind",  # type: ignore
    )

    foo: int


class NeedsenumobjectOutputFooOneOf_out_second(BaseModel):
    kind: Literal["out_second"] = Field(
        "out_second",
        alias="$kind",  # type: ignore
    )

    bar: int


NeedsenumobjectOutputFoo = Annotated[
    NeedsenumobjectOutputFooOneOf_out_first
    | NeedsenumobjectOutputFooOneOf_out_second
    | RiverUnknownValue,
    WrapValidator(translate_unknown_value),
]


class NeedsenumobjectOutput(BaseModel):
    foo: Optional[NeedsenumobjectOutputFoo] = None


NeedsenumobjectOutputTypeAdapter: TypeAdapter[Any] = TypeAdapter(NeedsenumobjectOutput)


class NeedsenumobjectErrorsFooAnyOf_0(RiverError):
    beep: Optional[Literal["err_first"]] = None


class NeedsenumobjectErrorsFooAnyOf_1(RiverError):
    borp: Optional[Literal["err_second"]] = None


NeedsenumobjectErrorsFoo = Annotated[
    NeedsenumobjectErrorsFooAnyOf_0
    | NeedsenumobjectErrorsFooAnyOf_1
    | RiverUnknownValue,
    WrapValidator(translate_unknown_value),
]


class NeedsenumobjectErrors(RiverError):
    foo: Optional[NeedsenumobjectErrorsFoo] = None


NeedsenumobjectErrorsTypeAdapter: TypeAdapter[Any] = TypeAdapter(NeedsenumobjectErrors)
