# Code generated by river.codegen. DO NOT EDIT.
from collections.abc import AsyncIterable, AsyncIterator
import datetime
from typing import (
    Any,
    Literal,
    Mapping,
    NotRequired,
    TypedDict,
)
from typing_extensions import Annotated

from pydantic import BaseModel, Field, TypeAdapter, WrapValidator
from replit_river.error_schema import RiverError
from replit_river.client import (
    RiverUnknownError,
    translate_unknown_error,
    RiverUnknownValue,
    translate_unknown_value,
)

import replit_river as river


def encode_NeedsenumobjectInputOneOf_in_first(
    x: "NeedsenumobjectInputOneOf_in_first",
) -> Any:
    return {
        k: v
        for (k, v) in (
            {
                "$kind": x.get("kind"),
                "value": x.get("value"),
            }
        ).items()
        if v is not None
    }


class NeedsenumobjectInputOneOf_in_first(TypedDict):
    kind: Annotated[Literal["in_first"], Field(alias="$kind")]
    value: str


def encode_NeedsenumobjectInputOneOf_in_second(
    x: "NeedsenumobjectInputOneOf_in_second",
) -> Any:
    return {
        k: v
        for (k, v) in (
            {
                "$kind": x.get("kind"),
                "bleep": x.get("bleep"),
            }
        ).items()
        if v is not None
    }


class NeedsenumobjectInputOneOf_in_second(TypedDict):
    kind: Annotated[Literal["in_second"], Field(alias="$kind")]
    bleep: int


NeedsenumobjectInput = (
    NeedsenumobjectInputOneOf_in_first | NeedsenumobjectInputOneOf_in_second
)


def encode_NeedsenumobjectInput(
    x: "NeedsenumobjectInput",
) -> Any:
    return (
        encode_NeedsenumobjectInputOneOf_in_first(x)
        if x["kind"] == "in_first"
        else encode_NeedsenumobjectInputOneOf_in_second(x)
    )


class NeedsenumobjectOutputFooOneOf_out_first(BaseModel):
    kind: Annotated[Literal["out_first"], Field(alias="$kind")] = "out_first"
    foo: int


class NeedsenumobjectOutputFooOneOf_out_second(BaseModel):
    kind: Annotated[Literal["out_second"], Field(alias="$kind")] = "out_second"
    bar: int


NeedsenumobjectOutputFoo = Annotated[
    NeedsenumobjectOutputFooOneOf_out_first
    | NeedsenumobjectOutputFooOneOf_out_second
    | RiverUnknownValue,
    WrapValidator(translate_unknown_value),
]


class NeedsenumobjectOutput(BaseModel):
    foo: NeedsenumobjectOutputFoo | None = None


NeedsenumobjectOutputTypeAdapter: TypeAdapter[NeedsenumobjectOutput] = TypeAdapter(
    NeedsenumobjectOutput
)


class NeedsenumobjectErrorsFooAnyOf_0(RiverError):
    beep: Literal["err_first"] | None = None


class NeedsenumobjectErrorsFooAnyOf_1(RiverError):
    borp: Literal["err_second"] | None = None


NeedsenumobjectErrorsFoo = Annotated[
    NeedsenumobjectErrorsFooAnyOf_0
    | NeedsenumobjectErrorsFooAnyOf_1
    | RiverUnknownError,
    WrapValidator(translate_unknown_error),
]


class NeedsenumobjectErrors(RiverError):
    foo: NeedsenumobjectErrorsFoo | None = None


NeedsenumobjectErrorsTypeAdapter: TypeAdapter[NeedsenumobjectErrors] = TypeAdapter(
    NeedsenumobjectErrors
)
