# Code generated by river.codegen. DO NOT EDIT.
from collections.abc import AsyncIterable, AsyncIterator
import datetime
from typing import (
    Any,
    Literal,
    Mapping,
    NotRequired,
    TypedDict,
)
from typing_extensions import Annotated

from pydantic import BaseModel, Field, TypeAdapter, WrapValidator
from replit_river.error_schema import RiverError
from replit_river.client import (
    RiverUnknownError,
    translate_unknown_error,
    RiverUnknownValue,
    translate_unknown_value,
)

import replit_river as river


def encode_ExecInit(
    x: "ExecInit",
) -> Any:
    return {
        k: v
        for (k, v) in (
            {
                "args": x.get("args"),
                "cwd": x.get("cwd"),
                "env": x.get("env"),
                "omitStderr": x.get("omitStderr"),
                "omitStdout": x.get("omitStdout"),
                "useReplitRunEnv": x.get("useReplitRunEnv"),
            }
        ).items()
        if v is not None
    }


class ExecInit(TypedDict):
    args: list[str]
    cwd: NotRequired[str | None]
    env: NotRequired[dict[str, str] | None]
    omitStderr: NotRequired[bool | None]
    omitStdout: NotRequired[bool | None]
    useReplitRunEnv: NotRequired[bool | None]


def encode_ExecInput(
    x: "ExecInput",
) -> Any:
    return {
        k: v
        for (k, v) in (
            {
                "$kind": x.get("kind"),
                "stdin": x.get("stdin"),
            }
        ).items()
        if v is not None
    }


class ExecInput(TypedDict):
    kind: Annotated[Literal["stdin"], Field(alias="$kind")]
    stdin: bytes


class ExecOutput(BaseModel):
    pass


ExecOutputTypeAdapter: TypeAdapter[ExecOutput] = TypeAdapter(ExecOutput)


class ExecErrors(RiverError):
    pass


ExecErrorsTypeAdapter: TypeAdapter[ExecErrors] = TypeAdapter(ExecErrors)
